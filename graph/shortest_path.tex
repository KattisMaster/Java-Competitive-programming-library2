\problemtitle{Shortest Path and Connectivity}

Parameter descriptions:
\begin{description}
\item[{\tt adj}] is an adjecency matrix. {\tt adj[i][j]} is the distance
   from {\tt i} to {\tt j}.
\item[{\tt edges}] is the graph given as an STL-container of
   {\tt vector}s, {\tt map}s or {\tt multimap}s
   (or {\tt set} in {\tt dijkstra\_1}) of the edges from each node.
   Edges can have negative distances, provided there is no negative cycle in
   the graph.
   Self and multiple edges are allowed.
\item[{\tt n}] is the number of nodes is the graph.
\item[{\tt min}] is filled in with the shortest distance to each node.
\item[{\tt path} or {\tt from}] is filled in with the node number from which
   each node was entered. (there is inconsistency in the name choice!)
\end{description}

\begin{algorithm}{Flood fill}
\reflisting{flood fill}
\usage{ \sourceline{ flood\_fill(edges, m, start, from, to); } }
\complexity{E}

Flood fills around {\tt start} changing the value {\tt from} to {\tt to}
in {\tt m}.
\end{algorithm}

\begin{algorithm}{Connected components}
\reflisting{connected components}
\usage{ \sourceline{ connected\_components(edges, m, n); } }
\complexity{V+E}

Fills in {\tt m}, identifying each node with a connected component number,
returning the number of connected components.
\end{algorithm}

\begin{algorithm}{Transitive Closure}
\reflisting{transitive closure}
\complexity{V^3}
\usage{ \sourceline{ transitive\_closure(adj, path, n); } }

The transitive closure, i.e. which nodes are connected, is found using
a sligthly modified Floyd-Warshall. The algorithm also gives a path between
two nodes, if they are connected.

The adjacency matrix is updated to contain whether nodes are connected.
\end{algorithm}

\begin{algorithm}{Floyd Warshall}
\reflisting{floyd warshall}
\complexity{V^3}
\usage{ \sourceline{ floyd\_warshall(adj, path,n); } }

Calculates the distances between all pairs of nodes.
The adjacency matrix is modified to contain the shortest distances.
\end{algorithm}

\begin{algorithm}{Dijkstra 1}
\reflisting{dijkstra 1}
\complexity{V+E}
\usage{ \sourceline{ dijkstra\_1(edges, min, path, start, n); } }
\characteristics{{\tt dijsktra\_1} shortest path when all edges have weight
1.}

Calculates the distance from a source to all other nodes.
\end{algorithm}

\begin{algorithm}{Dijkstra Prim}
\reflisting{dijkstra prim}
\reflisting{distfun}
\complexity{(V+E)\log V}
\usage{ \sourceline{ dijkstra\_1(edges, min, path, start, n, distfun, mst); } }

Calculates the distance from a source to all other nodes.
Takes two extra arguments:
{\tt distfun} is the edge distance function (see exaples).
{\tt mst = false} is used in {\tt prim} to get a
minimum spanning tree instead.
\end{algorithm}

\begin{algorithm}{Bellman-Ford}
\reflisting{bellman ford}
\reflisting{distfun}
\complexity{VE}

Calculates the distance from a source to all other nodes.
Returns whether there is a negative distance cycle in the graph.
\end{algorithm}

\begin{algorithm}{Get shortest path}
\reflisting{get shortest path}
\usage{ \sourceline{ get\_shortest\_path( from, path, start, end ) } }

Fills in {\tt path} with the nodes from {\tt start} to {\tt end}, using
{\tt from} to see where the path got from to the end.
\end{algorithm}
