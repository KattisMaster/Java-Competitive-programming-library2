\categorytitle{Data Structures}
\categorycontents{}
\newpage

\problemtitle{STL containers}
\begin{algorithm}{pair}
\usage{}
{\tt \#include <utility>} or\\
{\tt \#include <algorithm>}\\
{\tt make\_pair}, {\tt p.first}, {\tt p.second}, {\tt <}, {\tt ==}.
\end{algorithm}

\begin{algorithm}{string}
\usage{}
{\tt \#include <string>}\\
{\tt substr}, {\tt <}, {\tt ==}.
\end{algorithm}

\begin{algorithm}{vector}
\usage{}
{\tt \#include <vector>}\\
{\tt resize}, {\tt push\_back}, {\tt []}.
\end{algorithm}

\begin{algorithm}{deque}
\usage{}
{\tt \#include <deque>}\\
{\tt push\_front}, {\tt push\_back}, {\tt []}.
\end{algorithm}

\begin{algorithm}{set}
\usage{}
{\tt \#include <set>}\\
{\tt insert}, {\tt erase}, {\tt count}
\end{algorithm}

\begin{algorithm}{map}
\usage{}
{\tt \#include <map>}\\
{\tt []}, {\tt count}
\end{algorithm}

\begin{algorithm}{list}
\usage{}
{\tt \#include <list>}\\
{\tt push\_front}, {\tt push\_back}, {\tt []}.
\end{algorithm}

\begin{algorithm}{queue}
\usage{}
{\tt \#include <queue>}\\
{\tt push}, {\tt empty}, {\tt front}, {\tt pop}.
\end{algorithm}

\begin{algorithm}{stack}
\usage{}
{\tt \#include <stack>}\\
{\tt push}, {\tt empty}, {\tt top}, {\tt pop}.
\end{algorithm}

\begin{algorithm}{heap}
\usage{}
{\tt \#include <algorithm>}\\
{\tt make\_heap}, {\tt push\_heap}, {\tt pop\_heap}, {\tt sort\_heap}.
\end{algorithm}

\begin{algorithm}{priority queue}
\keyword{note}
The {\tt front()} is the element with the {\em highest} key.\\
\usage{}
{\tt \#include <queue>}\\
{\tt push}, {\tt empty}, {\tt front}, {\tt pop}.
\end{algorithm}

\problemtitle{Null vector}
\begin{algorithm}{null vector}
\reflisting{null vector}

{\tt null vector} acts like a vector, but simply keeps one value.
The value is reset and its reference returned for any index referenced.
\usage{\sourceline{ v[3612378] = 5; v[3612378] == 0; }}
\end{algorithm}

\problemtitle{Disjoint sets}
\begin{algorithm}{sets}
\reflisting{sets}

The {\tt Kruskal} minimum spanning tree algorithm uses a data structure
called {\tt sets} to efficiently determine whether two vertices belong to
the same tree.
\end{algorithm}

\problemtitle{Modifiable priority queue}
\begin{algorithm}{mpq}
\reflisting{mpq}

{\tt mpq} is a modifiable priority queue (implemented as a set). Its interface
is identical to that of a {\tt priority\_queue}. When an element should be
modified the {\tt update} method should be called as:
\sourceline{update(elem, oldvalue, newvalue)}
Where {\tt oldvalue} should be a \emph{reference} to the value of the
{\tt elem}.

A common use is to use indices as elements which is compared using external
containers.
\end{algorithm}

\problemtitle{Updatable heap}
\begin{algorithm}{update heap}
\reflisting{update heap}

An updatable heap has an interface identical to that of a
{\tt priority\_queue}.
The elements need to have a method {\tt set\_position} though. When an element
is changed, the {\tt key\_increased} or {\tt key\_decreased} method should
be called with its position as argument.
\end{algorithm}

\begin{sourceslandscape}
\code{null vector}{null_vector}
\code{sets}{sets}
\code{mpq}{mpq}
\code{update heap}{update_heap}
\end{sourceslandscape}
