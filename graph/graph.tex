\categorytitle{Graph}
\categorycontents{}

\problemtitle{Misc basics}

\begin{algorithm}{Bellman-Ford}
\complexity{VE}
\end{algorithm}
\code{bellman ford}{bellman_ford}


\begin{algorithm}{Shortest Tour}
\desc
Shortest tour from A to B to A again not using any edge twice, in an
undirected graph: Convert the graph to a directed graph.  Take the
shortest path from A to B.  Remove the paths used from A to B, but
also negate the lengths of the reverse edges.  Take the shortest path
again from A to B, using an algorithm which can handle negative-weight
edges, such as Bellman-Ford. Note that there is no negative-weight
\emph{cycles}.  The shortest tour has the length of the two shortest
paths combined. 
\end{algorithm}


\begin{algorithm}{Kruskal}
\usage{ \sourceline{kruskal( graph, tree, n );} }
\complexity{ E\log E }
\desc
{\bf NB!} Requires {\texttt sets.cc}!
The resulting tree which is returned in {\tt tree} may
be the same variable as the graph.
\reflisting{sets}
\end{algorithm}
\code{kruskal}{mst/kruskal}

\code{topo sort}{topo_sort}



\xinput{euler_cycle}
\xinput{network_flow}
\xinput{matching}
%\problemtitle{Planarity detection}

\sourcesection{Graph Misc}
\code{euler walk}{euler_walk}
\code{deBruijn}{deBruijn}
\code{deBruijn fast}{deBruijn_fast}

\sourcesection{Network Flow}
\code{flow graph}{maxflow/flow_graph}
\code{lift to front}{maxflow/lift_to_front}
\code{ford fulkerson}{maxflow/ford_fulkerson}

\sourcesection{Matching}
\code{hopcroft karp}{matching/hopcroft_karp}

\sourcesection{Maximum Weight Bipartite Matching}
\code{mwbm}{matching/max_weight_bipartite_matching}
\code{mwbm of max card}{matching/max_weight_b_m_of_max_card}
