\problemtitle{Shortest Path and Connectivity}

Parameter descriptions:
\begin{description}
\item[{\tt f}] is a function object that takes a node index and a funcion
object, and that for each edge from that node calls the function object with
the destination node index and distance of the edge. ({\tt f} is most
conveniently templatised on the type of the recieved function object.)
\item[{\tt adj}] is an adjecency matrix. {\tt adj[i][j]} is the distance
   from {\tt i} to {\tt j}.
\item[{\tt edges}] is the graph given as an STL-container of
   {\tt vector}s, {\tt map}s or {\tt multimap}s
   (or {\tt set} in {\tt dijkstra\_1}) of the edges from each node.
   Edges can have negative distances, provided there is no negative cycle in
   the graph.
   Self and multiple edges are allowed.
\item[{\tt n}] is the number of nodes is the graph.
\item[{\tt min}] is filled in with the shortest distance to each node.
\item[{\tt path} or {\tt from}] is filled in with the node number from which
   each node was entered. (there is inconsistency in the name choice!)
\end{description}

\begin{algorithm}{Flood fill}
\reflisting{flood fill}
\usage{ \sourceline{ flood\_fill(edges, m, start, from, to); } }
\complexity{E}
\desc
Flood fills around {\tt start} changing the value {\tt from} to {\tt to}
in {\tt m}.
\end{algorithm}

\begin{algorithm}{Connected components}
\reflisting{connected components}
\usage{ \sourceline{ connected\_components(edges, m, n); } }
\complexity{V+E}
\desc
Fills in {\tt m}, identifying each node with a connected component number,
returning the number of connected components.
\end{algorithm}

\begin{algorithm}{Transitive Closure}
\reflisting{transitive closure}
\complexity{V^3}
\usage{ \sourceline{ transitive\_closure(adj, path, n); } }
\desc
The transitive closure, i.e. which nodes are connected, is found using
a sligthly modified Floyd-Warshall. The algorithm also gives a path between
two nodes, if they are connected.

The adjacency matrix is updated to contain whether nodes are connected.
\end{algorithm}

\begin{algorithm}{Floyd Warshall}
\reflisting{floyd warshall}
\complexity{V^3}
\usage{ \sourceline{ floyd\_warshall(adj, path,n); } }
\desc
Calculates the distances between all pairs of nodes.
The adjacency matrix is modified to contain the shortest distances.
\end{algorithm}

\begin{algorithm}{Prijm}
\reflisting{prijm}
\reflisting{prijm1}
\reflisting{for edge}
\complexity{(V+E)\log V}
\usage{\sourceline{dijkstra(f, min, path, start);}}
\usage{\sourceline{prim(f, min, path, start);}}
\end{algorithm}

\begin{algorithm}{Dijkstra 1}
\reflisting{dijkstra 1}
\complexity{V+E}
\usage{ \sourceline{ dijkstra\_1(edges, min, path, start, n); } }
\desc
Calculates the distance from a source to all other nodes,
when all edges have weight 1.
\end{algorithm}

\begin{algorithm}{Dijkstra Prim}
\reflisting{dijkstra prim}
\reflisting{distfun}
\complexity{(V+E)\log V}
\usage{ \sourceline{ dijkstra\_prim(edges, min, path, start, n, distfun, mst); } }
\desc
Calculates the distance from a source to all other nodes.
Takes two extra arguments:
{\tt distfun} is the edge distance function (see exaples).
{\tt mst = false} is used in {\tt prim} to get a
minimum spanning tree instead.
\note{Dijkstra Prim can handle negative edge-weights but the complexity
is then worse, \ordo{V(V+E)\log V} (?). Bellman-Ford is better suited for this
case.}
\end{algorithm}

\begin{algorithm}{Dijkstra Prim Simple}
\reflisting{dijkstra prim simple}
\complexity{(V+E)V}
\usage{ \sourceline{ dijkstra\_prim\_simple(edges, min, path, start, n, mst); } }
\desc
Calculates the distance from a source to all other nodes.
Takes one extra arguments:
{\tt mst = false} is used in {\tt prim} to get a
minimum spanning tree instead.

\note{Dijkstra Prim Simple cannot handle negative edge-weights. It can
be modified to work with negative edge-weights by inserting
{\tt proc[dest]=false;} when a shorter route is found, but with increased
complexity.}
\end{algorithm}

\begin{algorithm}{Bellman-Ford}
\reflisting{bellman ford}
\reflisting{distfun}
\complexity{VE}
\desc
Calculates the distance from a source to all other nodes.
Returns whether there is a negative distance cycle in the graph.
\end{algorithm}

\begin{algorithm}{Bellman-Ford-2}
\reflisting{bellman ford 2}
\reflisting{distfun}
\complexity{VE}
\desc
Calculates the distance from a source to all other nodes.
Returns whether there is a negative distance cycle in the graph.
Instead of working with edge-lists as Bellman-Ford, the algorithm BF-2 uses
a single edge-list with pairs ((from,to), dist).
\end{algorithm}

\begin{algorithm}{Get shortest path}
\reflisting{get shortest path}
\usage{ \sourceline{ get\_shortest\_path( from, path, start, end ) } }
\desc
Fills in {\tt path} with the nodes from {\tt start} to {\tt end}, using
{\tt from} to see where the path got from to the end.
\end{algorithm}


\begin{algorithm}{Shortest Tour}
\desc
Shortest tour from A to B to A again not using any edge twice, in an
undirected graph:

Convert the graph to a directed graph.

Take the shortest path from A to B.

Remove the paths used from A to B, but also negate the lengths of the
reverse edges.

Take the shortest path again from A to B, using an algorithm which can handle
negative-weight edges, such as Bellman-Ford. Note that there is no
negative-weight \emph{cycles}.

The shortest tour has the length of the two shortest paths combined.
\end{algorithm}
