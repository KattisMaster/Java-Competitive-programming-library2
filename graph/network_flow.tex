\problemtitle{Network Flow}

Flow graphs are directed graphs with flow capacities on their edges.

To get quick access to the ``back edge'' of all egdes, a special flow edge
struct is used in the network flow algorithms.

\begin{algorithm}{flow graph}
\reflisting{flow graph}
\usage{ \sourceline{%
 flow\_add\_edge( edges, source, dest, cap [, back\_cap] ); }}
\desc
Flow graphs are constructed and updated by a couple of utility functions.

A flow graph should be an STL-container of {\tt vector}s with
{\tt flow\_edge}s ({\tt map}s are not allowed).

Edges should be added using {\tt flow\_add\_edge}.

Note that an edge {\emph must be} added only once for each pair,
simultaneously giving both forward and back capacity.
\end{algorithm}

\begin{algorithm}{lift to front}
\reflisting{lift to front}
\note{This is a much more effective algorithm than Ford Fulkerson,
even on bi-partite graphs, and suitable for any flow graph.}
\note{Ford Fulkerson {\it is} faster if $En_{aug~paths}<V^3$.}
\usage{ \sourceline{flow = lift\_to\_front(edges, source, sink);} }
\complexity{V^3}
\end{algorithm}

\begin{algorithm}{ford fulkerson}
\reflisting{ford fulkerson}
\desc
This is a DFS or BFS Ford Fulkerson which maximize the flow in the
augmenting paths. The BFS is more robust but may be slower.
\usage{ The maximum flow is calculated by repetitive calls
to {\tt flow\_increase1}:}
\sourceline{ while( ap = flow\_increase1(edges, source, sink) ) flow+=ap; }
\complexity{E\cdot n_{aug~paths}}
\end{algorithm}

\begin{algorithm}{ford fulkerson 1}
\reflisting{ford fulkerson 1}
\desc
This is a DFS Ford Fulkerson where all augmenting paths
are 1 and thus specially suited for bipartite graphs.
\usage{ The maximum flow is calculated by repetitive calls
to {\tt flow\_increase1}: }
\sourceline{ while( flow\_increase1(edges, source, sink) ) flow++; }
\complexity{E\cdot n_{aug~paths}}
\end{algorithm}

\begin{algorithm}{Min cut}
\desc
The minimum cut has the same capacity as the maximum flow,
but perhaps we want an algorithm for finding it?
\end{algorithm}

\begin{algorithm}{Flow constructions}
\keyword{Matching} in a bipartite graph. A multisource, multisink flow
with only one-capacities determines an optimal matching.
\keyword{Edge and Vertex Connectivity} of a graph, determines how connected
it is. For vertex connectivity, each node is split in two.
\keyword{Minimal cut} of a graph, generalization of edge connectivity. A
minimal cut is found by first finding a maximal flow. Then we consider the
set $A$ of all nodes that can be reached from the source using edges which
has capacity left (i.e. edges in the residue network). The edges between
$A$ and the complement of $A$ is a minimal cut.
\keyword{Escaping problem} on a grid, determines whether and how a set of
points may be connected by grid-lines to the edge.
\keyword{Minimal path cover} of a graph, determines a minimum set of paths to
cover it.
\end{algorithm}
