\clearpage
\categorytitle{Numerical}
\categorycontents{}

\problemtitle{Numerical datastructures}
\code{bigint}{numbers/bigint}
\code{sign}{numbers/sign}
\code{rational}{numbers/rational}
\code{polynomial}{polynomial}

\problemtitle{Equation solving}
\code{solve linear}{solve_linear}
\code{matrix inverse}{matrix_inverse}
\code{poly roots}{poly_roots}

\begin{algorithm}{Calculating determinant}
\desc {\tt determinant} and {\tt int\_determinant} both reduces the matrix
to an upper diagonal form using elementary row operations. There could be an
overflow in the integral variant and in that case the double variant
can be used instead, rounding the answer at the end. The strength of
{\tt int\_determinant} is that it can be used for {\tt long long} or
{\tt BigInt}. Note that it uses {\tt euclid} which could be rather
slow in the {\tt BigInt} case.
\end{algorithm}
\codenc{determinant}{determinant}
\codenc{int determinant}{int_determinant}

\code{sqrt}{sqrt}

\problemtitle{Optimization}
\begin{algorithm}{Simplex method}
\desc
Solves a linear minimization problem. The first row of the
input matrix is the objective function to be minimized. The
first column is the maximum allowed value for each linear row.
\end{algorithm}
\codenc{simplex}{simplex}

\begin{algorithm}{Conjugated gradient method}
\desc
Search direction in step $i$ is $d_i = g_i + \beta_i d_{i-1}$, where
$g_i$ is the gradient in step $i$ and $\beta_i =
\frac{|g_i|^2}{|g_{i-1}|^2}$ ($d_1 = g_1$).
\end{algorithm}

\begin{algorithm}{Knapsack Heuristic}
\complexity{\min(bound, nC)}
\note{Exact if {\tt bound} $\ge nC$}
\end{algorithm}
\codenc{knapsack}{knapsack}

\begin{algorithm}{Hopcroft}
\reflisting{hopcroft}
\complexity{Q^2\Sigma}
\desc
Automata state minimization.
\end{algorithm}
\codenc{hopcroft}{hopcroft}
