\categorytitle{Combinatorial}
\categorycontents{}

\problemtitle{Sorting}
\begin{algorithm}{sort}
  \usage{\sourceline{ sort( v.begin(), v.end(), less<int>() ) }}
\end{algorithm}

\begin{algorithm}{isort}
  \usage{\sourceline{ isort( array, n, idxarray, comp) }}
  \reflisting{isort}
\end{algorithm}

\begin{algorithm}{indexed comparator}
  \reflisting{indexed comparator}
\end{algorithm}

\begin{algorithm}{indexed less}
  \reflisting{indexed less}
\end{algorithm}

\problemtitle{Searching}
\begin{algorithm}{median -- nth element}
  \usage{\sourceline{ nth\_element( v.begin(), v.end(), 4 ) }}
  \begin{example}
	nth_element( v.begin(), v.end(), v.size() / 2 ) // mid value
  \end{example}
\end{algorithm}
\begin{algorithm}{binary search}
  \usage{\sourceline{ bool binary\_search( v.begin(), v.end(), 4 ) }}
  \usage{\sourceline{ iterator lower\_bound( v.begin(), v.end(), 4 ) }}
  \usage{\sourceline{ iterator upper\_bound( v.begin(), v.end(), 4 ) }}
\end{algorithm}
\begin{algorithm}{binary search (numerical)}
  \reflisting{binary search num}
  \usage{\sourceline{double binary\_search\_num( 0.0, 1.0, pred ); }}
\end{algorithm}
\begin{algorithm}{golden search}
  \reflisting{golden search}
  \usage{\sourceline{
 int golden\_search( f, l, r, \&min\_value ) == min\_index }}
\end{algorithm}

\problemtitle{Permutations}
\begin{algorithm}{next}
\usage{{\tt next\_permutation(begin, end [, comparator])}}
\end{algorithm}
\begin{algorithm}{previous}
\usage{{\tt prev\_permutation(begin, end [, comparator])}}
\end{algorithm}
\begin{algorithm}{random}
\usage{{\tt random\_shuffle(begin, end [, random\_number\_generator])}}
\end{algorithm}
\begin{algorithm}{permute}
\reflisting{permute}
\characteristics{{\tt permute} recursively generates all permutations
without comparisons. The permutations are given in lexiographically order
using the original order (i.e. permute on ``baa'' gives baa, aba, aab).
It can also be useful when the processing is done for each individual
position (unnecessary duplicate work is avoided). Repetitions of non-adjacent
elements will give strange results since there is no possible ordering
(i.e ``aba'').}
\usage{\sourceline{char a[n] = "caab"; permute(a+0,a+0,a+n);}}
\end{algorithm}
\xinput{counting}

\problemtitle{Hard Optimisation Problems}


\begin{algorithm}{Knapsack}
\reflisting{knapsack}
\usage{{\tt R res = knapsack<R>(n, C, costs, values [, bound = 500000]);}}
\complexity{\min(bound, nC)}

\characteristics{Knapsack heuristic. Returns the maximum value achievable. {\tt n} is the number of objects, {\tt C} is the kapacity of the knapsack, {\tt costs} is a random access container with the {\tt n} costs, and {\tt values} is a random access container with the {\tt n} values. {\tt bound} is an approximation factor; lower values of {\tt bound} means shorter running time, but also a greater risk that the algorithm will produce an incorrect answer (if $nC \le $ {\tt bound} and the costs are integers, the answer is ``guaranteed'' to be correct). Note that actually, all scaled values (i.e. multiplications with {\tt scale}) should be rounded upwards. However, empirical tests (using the test data from NADA Open 2002) has shown this approach to be less accurate (i.e. requiring a higher bound to produce a correct answer) in practice. For the NADA Open 2002 test cases, a bound of $\approx 90000$ was sufficient.}


\end{algorithm}

\begin{sourceslandscape}
\code{isort}{isort}
\code{indexed comparator}{indexed_comparator}
\code{indexed less}{indexed_less}
\code{binary search num}{binary_search_num}
\code{golden search}{golden_search}
\code{permute}{permute}
\code{choose}{../numerical/choose}
\code{multinomial}{../numerical/multinomial}
\code{nperms}{../numerical/nperms}
\code{stirling1}{../numerical/stirling1}
\code{stirling}{../numerical/stirling}
\code{euler}{../numerical/euler}
\code{euler2}{../numerical/euler2}
\code{knapsack}{knapsack}
\end{sourceslandscape}
