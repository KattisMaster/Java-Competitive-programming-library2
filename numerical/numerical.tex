\categorytitle{Number Theory}
\categorycontents{}

\problemtitle{Divisibility}


\begin{algorithm}{GCD}
\reflisting{gcd}
\usage{ \sourceline{d = gcd( a, b );} }
\complexity{ \log(b) }

\reflisting{gcd fast}
\usage{ \sourceline{d = gcd\_fast(a, b);} }
\complexity{ \log(a) + \log(b) }
\note{The \sourceline{gcd\_fast} routine is slightly more writing
than the usual gcd routine, but can be useful where speed is
{\em really essential}, as it only uses subtraction and shift operations
instead of the evil modulo.}

\valladolid{202}
\end{algorithm}

\def\lcm{\mathrm{lcm}}
\begin{algorithm}{LCM}
\desc $\lcm(a,b)=\frac{ab}{\gcd(a,b)}$
\end{algorithm}

\begin{algorithm}{Euclid}

\reflisting{euclid}
\usage{ \sourceline{d = euclid( a, b, \&x, \&y );} }
\desc
$x, y$ will satisfy $ax+by=d$ after the call.
\reflisting{poseuclid}
\desc
$x, y\ge 0$ will satisfy $ax-by=\pm d$ after the call.
\complexity{ \log(b) }
\note{$x$ and $y$ have the smallest absolute value}
\begin{example}
	euclid( 10, 6, x, y ) == 2, x == -1, y == 2
\end{example}
\valladolid{202}
\end{algorithm}

\begin{algorithm}{Chinese remainder theorem}
\reflisting{chinese}
\desc
Given $x=a\mod m$, $x=b\mod n$, calculates $x\mod mn$.
\note{When poseuclid is used, $mn$ may be returned.}
\end{algorithm}

\begin{algorithm}{$\phi$-function}
\reflisting{phi}
\desc $\phi(n)=\#\{d<n|\gcd(n,d)=1\}$
\desc If $n=\prod p_i^{k_i}$,
$\phi(n)=n\prod\left(1-\frac{1}{p_i}\right)=\prod p_i^{k_i-1}(p_i-1)$
\complexity{ \sqrt{n} }
\end{algorithm}

\begin{algorithm}{Perfect numbers}
\desc
When $n$ is even, it is a perfect number iff it is of the form
$\frac{p (p+1)}{2}$, where $p$ is a Mersenne prime. Mersenne primes are primes
of the form $p = 2^k - 1$. The first 27 Mersenne primes (and thus the first 27
even perfect numbers) are obtained for $k =$ 2, 3, 5, 7, 13, 17, 19, 31, 61,
89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213,
19937, 21701, 23209, 44497.

It is conjectured that there are no odd perfect numbers.
\end{algorithm}

\problemtitle{Primes}

The first 100 primes are:
{\small
\begin{verbatim}
       2       3       5       7      11      13      17      19      23 
      29      31      37      41      43      47      53      59      61 
      67      71      73      79      83      89      97     101     103 
     107     109     113     127     131     137     139     149     151 
     157     163     167     173     179     181     191     193     197 
     199     211     223     227     229     233     239     241     251 
     257     263     269     271     277     281     283     293     307 
     311     313     317     331     337     347     349     353     359 
     367     373     379     383     389     397     401     409     419 
     421     431     433     439     443     449     457     461     463 
     467     479     487     491     499     503     509     521     523 
     541
\end{verbatim}
}

The 1000th prime is 7919. The first every 10000th primes are:
{\small
\begin{verbatim}
  104729  224737  350377  479909  611953  746773  882377 1020379 1159523
 1299709
\end{verbatim}
}

Some primes closest below powers of two are (Mersenne primes are starred):
{\small
\begin{verbatim}
       3*      7*     13      31*     61     127*    251     509    1021
    2039    4093    8191*  16381   32749   65521  131071* 262139  524287*(19)
 1048573              2147483647*(31)                2305843009213693951*(61)
     618970019642690137449562111*(89)  162259276829213363391578010288127*(107)
                                 170141183460469231731687303715884105727*(127)
\end{verbatim}
}


\begin{algorithm}{Primes}
\reflisting{primes}
\usage{ \sourceline{primes<int> p; p.generate(1000); n = factor(10); n==2;} }
\desc
{\tt primes} calculates a vector of primes and has a factor method which
returns the smallest factor in the given integer.
\end{algorithm}

\begin{algorithm}{Prime Sieve}
\reflisting{prime sieve}
\usage{ \sourceline{prime\_sieve p(1000); p.isprime(10)==false;} }
\desc
{\tt prime\_sieve} calculates a bool-vector containing whether an integer
is prime. It is faster than {\tt primes} when dealing with large numbers.
Returns whether an integer is prime in constant time.
\end{algorithm}

\begin{algorithm}{Primes Many}
\reflisting{primes many simple}
\reflisting{primes many fast}
\usage{ \sourceline{primes\_many p(100000); p.primes[2] == 5;} }
\desc
{\tt primes\_many\_simple} and {\tt primes\_many\_fast}
calculates a vector of primes and is suitable when dealing with lots of
primes (10000 or more). It calculates them by first sieving and then
putting them into an array.
\end{algorithm}

\begin{algorithm}{Miller-Rabin}
\reflisting{miller-rabin}
\usage{ \sourceline{ isprime\_rabin\_miller( n, s ); } }
\complexity{ s \log(n) }
\desc
{\tt isprime\_rabin\_miller} is a probabilistic primality
test. It will never say that a prime is composite but may erroneous claim
that a composite number is prime. The argument {\tt s} is the number of
iterations to be used. The probability of a false answer is not more than
$2^{-s}$ so $s=50$ is more than enough for most applications. The integer
to be tested {\tt n} may be as large as $2^{63}-1$.
\end{algorithm}

\begin{algorithm}{Number of divisors}
\reflisting{ndivisors}
\usage{ \sourceline{primes\_many\_fast p(100000);
	ndivisors\_prob(23424234234243,p.primes)==8;} }
\desc
{\tt ndivisors} and {\tt ndivisors\_prob} calculates
the number of divisors. {\tt ndivisors} needs a prime-table with all primes
upto the square root of the number and {\tt ndivisors\_prob} only primes as
large as the third root of the number. The second algorithm uses a
probabilistic primality test (Miller-Rabin).
\end{algorithm}

\begin{algorithm}{Factor}
\reflisting{factor}
\usage{\sourceline{int n = 2*2*3*3*5; vector<pair<int, int> > \&facs =
Factor(n);} }
\desc
{\tt Factor} calculates the prime factorization of an integer.
The returned vector is an increasing sequence of primes/exponents pairs.
That is (letting $p_i = $ {\tt Factor(n)[i].first}, and $e_i = $
{\tt Factor(n)[i].second}): $n = \prod_i \, p_i^{e_i}$, where all $p_i$ are
prime and $i < j \Leftrightarrow p_i < p_j$.

As it basically works by dynamic programming, {\tt Factor} requires
roughly $\mathcal{O}(n \log \log n)$ memory, but the good news is that
the time complexity for factoring all numbers from $1$ to $n$ is also
roughly $\mathcal{O}(n \log \log n)$, and that once a number's been
factored, {\tt Factor} remembers the factorization and can give it in
constant time.
\end{algorithm}

\problemtitle{Josephus}
\begin{algorithm}{Josephus}
\reflisting{josephus}
\complexity{log_{\frac{k}{k-1}}(n)}
\desc
Josephus is the problem to determine which person remains when repeatedly
removing the $k$:th person from a total of $n$ persons (cyclic).
\end{algorithm}


\problemtitle{Random}
\begin{algorithm}{Pseudo random numbers}
\reflisting{pseudo}
\desc {\tt pseudo} gives a pseudo-random integer in
$[0,2^{31}-1]$.
\desc {\tt ullpseudo} gives a pseudo-random integer in
$[0,2^{62}-1]$.
\desc {\tt fpseudo} gives a pseudo-random number in
$[0,1)$.
\complexity{1}
\end{algorithm}

\problemtitle{Linear Equations}
\begin{algorithm}{Solving linear equations}
\reflisting{solve linear}
\reflisting{solve linear TO}
\end{algorithm}

\begin{algorithm}{Calculating determinant}
\reflisting{determinant}
\reflisting{int determinant}
\desc {\tt determinant} and {\tt int\_determinant} both reduces the matrix
to an upper diagonal form using elementary row operations. There could be an
overflow in the integral variant and in that case the double variant
can be used instead, rounding the answer at the end. The strength of
{\tt int\_determinant} is that it can be used for {\tt long long} or
{\tt BigInt}. Note that it uses {\tt euclid} which could be rather
slow in the {\tt BigInt} case.
\end{algorithm}

\problemtitle{Big numerical operations}
\begin{algorithm}{exp}
\reflisting{exp}
\complexity{\log{e}\textrm{ ops}}
\desc
{\tt exp} calculates $b^e$ by repeated squaring.
\end{algorithm}

\begin{algorithm}{mulmod}
\reflisting{mulmod}
\usage{ \sourceline{ mulmod(5678945893454353ULL, 2423948234343ULL,
	31231231231231231ULL)}\\
\sourceline{ == 14355903581119892; } }
\desc
{\tt mulmod} calculates $ab\mbox{ mod } n$ in a way that
allows numbers as large as MAXINT/2 to be used (which would otherwise give
an overflow).
\end{algorithm}

\begin{algorithm}{expmod}
\reflisting{expmod}
\complexity{\log{e}\textrm{ ops}}
\desc {\tt expmod} calculates $b^e\mod n$ by repeated squaring.
\end{algorithm}

\begin{algorithm}{Bit manipulations}
\reflisting{bitmanip}
\desc
Lowest bit, sign, power-of-two check, power-of-two round-up,
next number with same number of bits, bit count, bit reversal,
binary length.
\end{algorithm}

\problemtitle{Coordinates and directions}
\begin{algorithm}{coords}
\reflisting{coords}
\usage{\sourceline{%
sqrX X(cols); idx = X(3, 4); X(idx, \&r, \&c);}}
\usage{\sourceline{%
cubeX X(rows, cols); idx = X(3, 4, 5); X(idx, \&l, \&r, \&c);}}
\usage{\sourceline{%
quadX X(levs, rows, cols); idx = X(3, 4, 5, 6); X(idx, \&h, \&l, \&r, \&c);}}
\usage{\sourceline{%
triX X; idx = X(3, 4); X(idx, \&r, \&c);}}
\desc
Coordinate to index and index to coordinate calculations for
plane, space and hyperspace grid and plane triangle layouts.

\usage{\sourceline{dxy(dir, \&dx, \&dy);}}
\usage{\sourceline{drc(dir, \&dr, \&dc);}}
\usage{\sourceline{dknight(dir, \&dr, \&dc);}}
\desc
Direction to x and y or row and column displacement. {\tt dir} values
0, 1, 2, 3 mod 4 correspond to right, up, left, right or north, east, south,
west, respectively. Or chess knight jump directions.
\end{algorithm}

\problemtitle{Optimization}
\begin{algorithm}{Simplex method}
\reflisting{simplex}
\desc
Solves a linear minimization problem. The first row of the
input matrix is the objective function to be minimized. The
first column is the maximum allowed value for each linear row.
\end{algorithm}

\problemtitle{Finding roots of polynomials}
\begin{algorithm}{Newton's method}
\reflisting{poly roots}
\desc
Finds roots of a polynomial without multiple roots. The roots are found from
the left to the right and the input {\tt xmin} variable needs to be lesser than
all roots. A sufficiently small value (?) is
$-\sum_{i=1}^n |a_i|/|a_0|-\epsilon$ where the polynomial is
$a_0 x^n + a_1 x^{n-1} + \dots + a_n$.
\end{algorithm}

\begin{algorithm}{Newton's method}
\reflisting{poly roots bisect}
\desc
Finds roots of a polynomial $p$ without multiple roots. The roots are found by
bisecting a given interval until it contains $\mathrm{deg}(p)$ sign-changing
intervals. Then find the roots with either Newton's algorithm (with bisective
fall-back) or the bisective method.
\end{algorithm}

\begin{sourceslandscape}

\sourcesection{Divisibility}

\code{gcd}{gcd}
\code{gcd fast}{gcd_fast}
\code{euclid}{euclid}
\code{poseuclid}{poseuclid}
\code{chinese}{chinese}
\code{phi}{phi}

\sourcesection{Primes}
\code{primes}{primes}
\code{primes many simple}{primes_many_simple}
\code{primes many fast}{primes_many_fast}
\code{prime sieve}{prime_sieve}
\code{miller-rabin}{miller-rabin}
\code{ndivisors}{ndivisors}
\code{ndivisors prob}{ndivisors_prob}
\code{factor}{factor}

\sourcesection{Linear Algebra}
\code{solve linear}{solve_linear}
\code{solve linear TO}{solve_linear_TO}
\code{determinant}{determinant}
\code{int determinant}{int_determinant}

\sourcesection{Numerical Misc}
\code{josephus}{josephus}
\code{pseudo}{pseudo}
\code{exp}{exp}
\code{mulmod}{mulmod}
\code{expmod}{expmod}

\code{bitmanip}{bitmanip}
\code{coords}{coords}

\sourcesection{Optimization}
\code{simplex}{simplex}
\code{polynom}{polynom}
\code{poly roots}{poly_roots}
\code{poly roots bisect}{poly_roots_bisect}

\end{sourceslandscape}
