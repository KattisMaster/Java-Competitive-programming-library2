\problemtitle{Euler walk}

\begin{algorithm}{Euler walk}
\reflisting{euler walk}
\complexity{ E }
\usage{\sourceline{%
 euler\_walk( V \&edges, int start, list<int> \&path, bool cyclic ) }}

\desc
Find an eulerian walk in a directed graph, i.e. a walk traversing all
edges exactly once.

The algorithm \emph{assumes} that there exists an eulerian walk. If it does not
exists, it will return any maximal path, not neccessarily the longest.

If the graph is not cyclic, the start node must be a node with
$\mathrm{deg}_{out}-\mathrm{deg}_{in} = 1$.

{\tt euler\_walk} can be used to test if a graph has an eulerian walk by first
finding a start-node (or any node if it is cyclic) and then checking
if {\tt path.size() == nrOfEdges+1}. But obviously this is slower than checking
that all out degrees are equal to the in degrees (or exactly one vertex has
an extraneous entering edge and another vertex an extraneous leaving edge) and
that the graph is connected.

Set {\tt cyclic=true} if the path found must be cyclic, this is mostly of
internal use.

{\tt edges} is a vector/array with $V$ edge-containers. The edge-containers
should contain vertex-indices, and may contain repeated indices
(i.e. multiple edges). {\bf WARNING!} {\tt edges} is modified and emptied by
the algorithm.

{\tt path} should be empty prior to the call and contains the euler-path
given as \emph{vertex numbers}. The first vertex is {\tt start} which also is
the last vertex if the path is cyclic.

\item[Lexicographic Path] If the edges are sorted in lexicographic order for
each vertex, the resulting path will be lexicographically ordered. This is
accomplished by the algorithm, adding extra loops from the end first.
\end{algorithm}

\begin{algorithm}{Chinese postman}
\desc
A generalised euler path/cycle problem, finding the shortest path/cycle that
visits all edges even if some edges have to be traversed several times.
\end{algorithm}

\problemtitle{De Bruijn Sequences}
Let $\Omega$ be an alphabet of size $\sigma$. A de Bruijn sequence is a
sequence such that all words on $L$ letters appear as a contiguous subrange
of it. In a cyclic de Bruijn sequences a word may also wrap around the string.
The shortest cyclic de Bruijn sequence is of length $\sigma^L$ and the
shortest non-cyclic de Bruijn sequence is of length $\sigma^L+L-1$.

The shortest de Bruijn sequence of all words on $3$ letters in the alphabet
$\{0,1\}$ which is lexicographically smallest is

$00011101$ (cyclic)

$0001110100$ (non-cyclic)

\begin{algorithm}{de Bruijn}
\reflisting{deBruijn}
\reflisting{deBruijn fast}
\complexity{ N^L }
\usage{\sourceline{%
 deBruijn( int N, int L, char symbols[N] ) }}

\desc
{\tt N} is the size of the alphabet and {\tt symbols} the corresponding
letters. {\tt L} is the length of the words that should appear in the de
Bruijn sequence.

The output is given as {\tt cout}-statements.
\end{algorithm}
